package asg.asts;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import com.google.common.base.Charsets;
import com.google.common.io.Files;

public class FileGenerator {
	public static final String PARSEQ_COMMENT = "// generated by abstract-syntax-gen";
	private File outputFolder;
	private List<File> oldFiles = new LinkedList<>();
	
	public FileGenerator(File outputFolder) {
		this.outputFolder = outputFolder;
		outputFolder.mkdirs();

		oldFiles.addAll(Arrays.asList(outputFolder.listFiles()));
	}

	public void createFile(String name, StringBuilder sb) {
		String filename = name;
		File file = new File(outputFolder, filename);
	
		boolean writeFile = false;
		if (file.exists()) {
			// file already exists -> compare contents
			try {
				String content = Files.toString(file, Charsets.UTF_8);
				if (!sb.toString().equals(content)) {
					// files differ, rewrite:
					writeFile = true;
				}
			} catch (IOException e) {
				abort("Error: Could not read file " + filename);
			}
		} else {
			// file does not exist -> write it
			writeFile = true;
		}
		
		
		if (writeFile) {
			try {
				Files.write(sb, file, Charsets.UTF_8);
			} catch (IOException e) {
				abort("Error: Could not write file " + filename);
			}
		}
		oldFiles.remove(file);
	}
	
	public void abort(String string) {
		System.err.println(string);
		System.exit(1);
	}
	
	public void removeOldFiles() {
		for (File old : oldFiles) {
			try {
				if (Files.readFirstLine(old, Charsets.UTF_8).startsWith(PARSEQ_COMMENT)) {
					System.out.println("removing file: " + old);
					if (old.getName().endsWith(".backup")) {
						old.delete();
					} else {
						old.renameTo(new File(old.getAbsolutePath() + ".backup"));
					}
				}
			} catch (IOException e) {
				throw new Error(e);
			}			
		}
	}

}